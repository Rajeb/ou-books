
############ Calculate miimum distance #############


import pandas as pd
import numpy as np
from scipy.spatial import KDTree
import os

# Load event locations into a DataFrame
df_events = pd.DataFrame({
    'latitude': [34.1, 35.2, 36.3, 37.4],  # Example latitudes (add your actual data)
    'longitude': [-118.5, -119.6, -120.7, -121.8]  # Example longitudes (add your actual data)
})

# Define water body CSV files
water_files = ['water_bodies1.csv', 'water_bodies2.csv', 'water_bodies3.csv']

# Define checkpoint file
checkpoint_file = 'min_distances_checkpoint.csv'

# Load checkpoint if it exists
if os.path.exists(checkpoint_file):
    df_events = pd.read_csv(checkpoint_file)
    print("Checkpoint loaded.")
else:
    # Initialize columns for each water file
    for water_file in water_files:
        df_events[f'min_distance_{water_file}'] = np.nan
    df_events['min_distance_overall'] = np.nan

# Function to process water body CSV in chunks and calculate minimum distance
def process_water_bodies_in_chunks(water_file, df_events, chunk_size=10000):
    min_distances = []

    # Iterate through the water body CSV file in chunks
    for chunk in pd.read_csv(water_file, chunksize=chunk_size):
        # Filter out zero values or no-data values (assuming no-data is -9999 or adjust accordingly)
        chunk = chunk[(chunk['value'] != 0) & (chunk['value'] != -9999)]
        
        # Build KDTree from the chunk's water body locations
        water_tree = KDTree(chunk[['latitude', 'longitude']])
        
        # Calculate minimum distance for each event in df_events
        distances, indices = water_tree.query(df_events[['latitude', 'longitude']], k=1)
        
        # Store the minimum distances
        min_distances.append(distances)

    # Combine all minimum distances from chunks
    return np.min(min_distances, axis=0)

# Calculate the minimum distances for each event from all water files
total_events = len(df_events)
for idx, event in df_events.iterrows():
    # Skip if this event has already been processed (i.e., min_distance_overall is not NaN)
    if not pd.isna(event['min_distance_overall']):
        continue

    # Process the event for each water file
    for water_file in water_files:
        min_distances = process_water_bodies_in_chunks(water_file, df_events.iloc[[idx]])  # Calculate for one event
        df_events.at[idx, f'min_distance_{water_file}'] = min_distances[0]
    
    # After processing all water files, find the overall minimum distance for the event
    df_events.at[idx, 'min_distance_overall'] = df_events.loc[idx, [f'min_distance_{file}' for file in water_files]].min()
    
    # Save the DataFrame to the checkpoint file after each event
    df_events.to_csv(checkpoint_file, index=False)
    
    # Calculate and print the percentage progress
    progress_percentage = (idx + 1) / total_events * 100
    print(f"Processed event {idx + 1}/{total_events} ({progress_percentage:.2f}%)")

# After processing all events, the final results are saved
df_events.to_csv('final_min_distances.csv', index=False)
print("Processing complete. Final results saved to 'final_min_distances.csv'.")















import rasterio
import numpy as np
import pandas as pd
from scipy.spatial import KDTree

def get_raster_df_chunk(raster_path, window, no_data_value):
    """
    Read a chunk of the raster data and return a DataFrame with valid pixel coordinates and values.
    :param raster_path: Path to the raster file
    :param window: Tuple defining the chunk to read (row_start, row_stop, col_start, col_stop)
    :param no_data_value: No-data value to filter out
    :return: DataFrame with raster coordinates and values
    """
    with rasterio.open(raster_path) as src:
        # Read the chunk of the raster data
        raster_data = src.read(1, window=window)
        
        # Get the coordinates of the pixels within the chunk
        rows, cols = np.where(raster_data != no_data_value)
        raster_values = raster_data[rows, cols]
        coords = [src.xy(row + window[0], col + window[2]) for row, col in zip(rows, cols)]
        
    return pd.DataFrame({'latitude': [c[1] for c in coords], 'longitude': [c[0] for c in coords], 'value': raster_values})

def process_raster_in_chunks(raster_path, chunk_size=512):
    """
    Process the raster file in chunks and return a DataFrame with all valid pixel coordinates and values.
    :param raster_path: Path to the raster file
    :param chunk_size: Size of each chunk
    :return: DataFrame with all valid pixel coordinates and values
    """
    with rasterio.open(raster_path) as src:
        height, width = src.height, src.width
        no_data_value = src.nodata
        
        # Initialize an empty list to collect DataFrames
        all_chunks_df = []
        
        # Iterate over chunks of the raster
        for row_start in range(0, height, chunk_size):
            row_stop = min(row_start + chunk_size, height)
            for col_start in range(0, width, chunk_size):
                col_stop = min(col_start + chunk_size, width)
                window = ((row_start, row_stop), (col_start, col_stop))
                
                # Read and process the chunk
                chunk_df = get_raster_df_chunk(raster_path, window, no_data_value)
                all_chunks_df.append(chunk_df)
        
        # Combine all chunks into a single DataFrame
        return pd.concat(all_chunks_df, ignore_index=True)

# Example usage:
raster_path = 'large_raster.tif'
chunk_size = 512  # Adjust chunk size based on available memory

# Process raster file in chunks
raster_df = process_raster_in_chunks(raster_path, chunk_size)

# Prepare your DataFrame with event locations
df_events = pd.DataFrame({
    'latitude': [35.0, 34.5],  # Example latitudes
    'longitude': [-120.5, -121.0]  # Example longitudes
})

# Function to calculate minimum distance using KDTree
def calculate_min_distance_kdtree(lat, lon, raster_df):
    tree = KDTree(raster_df[['latitude', 'longitude']])
    event_coords = np.array([lat, lon])
    _, indices = tree.query(event_coords, k=1)
    min_distance = np.linalg.norm(event_coords - raster_df.iloc[indices][['latitude', 'longitude']].values)
    return min_distance

# Calculate minimum distances for each event
for idx, row in df_events.iterrows():
    lat, lon = row['latitude'], row['longitude']
    min_distance = calculate_min_distance_kdtree(lat, lon, raster_df)
    df_events.loc[idx, 'min_distance'] = min_distance

print(df_events)












--------------------------------------------------------------

t pandas as pd
from scipy.spatial import distance

# Function to filter raster based on a bounding box around the event location
def get_nearby_raster_values(lat, lon, src, buffer_distance=0.1):
    """
    Returns the raster values and their coordinates within a buffer around the given lat, lon.
    :param lat: Latitude of the event
    :param lon: Longitude of the event
    :param src: Opened rasterio object
    :param buffer_distance: Buffer distance (degrees) around the event location
    :return: DataFrame with nearby raster values and coordinates
    """
    # Get the raster's bounds in world coordinates
    minx, miny, maxx, maxy = src.bounds

    # Define the bounding box around the event
    left = lon - buffer_distance
    right = lon + buffer_distance
    bottom = lat - buffer_distance
    top = lat + buffer_distance

    # Ensure the bounding box does not exceed raster bounds
    left = max(left, minx)
    right = min(right, maxx)
    bottom = max(bottom, miny)
    top = min(top, maxy)

    # Get the pixel window that covers the bounding box
    row_start, col_start = src.index(left, top)
    row_stop, col_stop = src.index(right, bottom)

    # Read the subset of the raster data within the bounding box
    window = ((row_start, row_stop), (col_start, col_stop))
    raster_subset = src.read(1, window=window)

    # Get the coordinates of the pixels within the window
    rows, cols = np.where(raster_subset != src.nodata)
    raster_values = raster_subset[rows, cols]
    coords = [src.xy(row + row_start, col + col_start) for row, col in zip(rows, cols)]

    # Create a DataFrame with the coordinates and values
    raster_df = pd.DataFrame(coords, columns=['latitude', 'longitude'])
    raster_df['value'] = raster_values

    return raster_df













# Step 1: Function to extract raster data and return it as a DataFrame
def raster_to_dataframe(raster_path):
    with rasterio.open(raster_path) as src:
        raster_data = src.read(1)  # Reading the first band of the raster
        no_data_value = src.nodata
        transform = src.transform

        # Generate arrays of pixel coordinates (row, col) and filter no-data values
        rows, cols = np.where(raster_data != no_data_value)
        raster_values = raster_data[rows, cols]

        # Convert pixel (row, col) to lat/long using the transform
        lat_long_coords = np.array([src.transform * (col, row) for row, col in zip(rows, cols)])
        lats, lons = zip(*lat_long_coords)

        # Create a DataFrame with lat, lon, and raster values
        df_raster = pd.DataFrame({
            'latitude': lats,
            'longitude': lons,
            'raster_value': raster_values
        })

    return df_raster

# Step 2: Prepare your list of raster files
raster_files = ['raster1.tif', 'raster2.tif', 'raster3.tif']

# Step 3: Convert each raster file to a DataFrame and store it in a list
raster_dfs = []
for raster_path in raster_files:
    df_raster = raster_to_dataframe(raster_path)
    raster_dfs.append(df_raster)

# Step 4: Print the first few rows of one of the raster DataFrames
print(raster_dfs[0].head())  # This will print the first few rows of the first raster's DataFrame
